/**
 * 
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "http://localhost:6100/api/0.1/".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

/**
 * A type of aspect in the registry.
 */
export interface AspectDefinition {
    /**
     * The unique identifier for the aspect type.
     */
    "id": string;
    /**
     * The name of the aspect.
     */
    "name": string;
    /**
     * The JSON Schema of this aspect.
     */
    "jsonSchema"?: any;
}

export interface BadRequest {
    "message": string;
}

/**
 * A record in the registry, usually including data for one or more aspects.
 */
export interface Record {
    /**
     * The unique identifier of the record
     */
    "id": string;
    /**
     * The name of the record
     */
    "name": string;
    /**
     * The aspects included in this record
     */
    "aspects": any;
}

/**
 * A summary of a record in the registry.  Summaries specify which aspects are available, but do not include data for any aspects.
 */
export interface RecordSummary {
    /**
     * The unique identifier of the record
     */
    "id": string;
    /**
     * The name of the record
     */
    "name": string;
    /**
     * The list of aspect IDs for which this record has data
     */
    "aspects": Array<string>;
}



/**
 * AspectDefinitionsApi - fetch parameter creator
 */
export const AspectDefinitionsApiFetchParamCreator = {
    /** 
     * Create a new aspect
     * 
     * @param aspect The definition of the new aspect.
     */
    create(params: {  "aspect": AspectDefinition; }, options?: any): FetchArgs {
        // verify required parameter "aspect" is set
        if (params["aspect"] == null) {
            throw new Error("Missing required parameter aspect when calling create");
        }
        const baseUrl = `/aspects`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["aspect"]) {
            fetchOptions.body = JSON.stringify(params["aspect"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a list of all aspects
     * 
     */
    getAll(options?: any): FetchArgs {
        const baseUrl = `/aspects`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get an aspect by ID
     * 
     * @param id ID of the aspect to be fetched.
     */
    getById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getById");
        }
        const baseUrl = `/aspects/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Modify an aspect by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param id ID of the aspect to be saved.
     * @param aspectPatch The RFC 6902 patch to apply to the aspect.
     */
    patchById(params: {  "id": string; "aspectPatch": any; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling patchById");
        }
        // verify required parameter "aspectPatch" is set
        if (params["aspectPatch"] == null) {
            throw new Error("Missing required parameter aspectPatch when calling patchById");
        }
        const baseUrl = `/aspects/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["aspectPatch"]) {
            fetchOptions.body = JSON.stringify(params["aspectPatch"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Modify an aspect by ID
     * Modifies the aspect with a given ID.  If an aspect with the ID does not yet exist, it is created.
     * @param id ID of the aspect to be saved.
     * @param aspect The aspect to save.
     */
    putById(params: {  "id": string; "aspect": AspectDefinition; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling putById");
        }
        // verify required parameter "aspect" is set
        if (params["aspect"] == null) {
            throw new Error("Missing required parameter aspect when calling putById");
        }
        const baseUrl = `/aspects/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["aspect"]) {
            fetchOptions.body = JSON.stringify(params["aspect"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AspectDefinitionsApi - functional programming interface
 */
export const AspectDefinitionsApiFp = {
    /** 
     * Create a new aspect
     * 
     * @param aspect The definition of the new aspect.
     */
    create(params: { "aspect": AspectDefinition;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AspectDefinition> {
        const fetchArgs = AspectDefinitionsApiFetchParamCreator.create(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a list of all aspects
     * 
     */
    getAll(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AspectDefinition>> {
        const fetchArgs = AspectDefinitionsApiFetchParamCreator.getAll(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get an aspect by ID
     * 
     * @param id ID of the aspect to be fetched.
     */
    getById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AspectDefinition> {
        const fetchArgs = AspectDefinitionsApiFetchParamCreator.getById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Modify an aspect by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param id ID of the aspect to be saved.
     * @param aspectPatch The RFC 6902 patch to apply to the aspect.
     */
    patchById(params: { "id": string; "aspectPatch": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AspectDefinition> {
        const fetchArgs = AspectDefinitionsApiFetchParamCreator.patchById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Modify an aspect by ID
     * Modifies the aspect with a given ID.  If an aspect with the ID does not yet exist, it is created.
     * @param id ID of the aspect to be saved.
     * @param aspect The aspect to save.
     */
    putById(params: { "id": string; "aspect": AspectDefinition;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AspectDefinition> {
        const fetchArgs = AspectDefinitionsApiFetchParamCreator.putById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AspectDefinitionsApi - object-oriented interface
 */
export class AspectDefinitionsApi extends BaseAPI {
    /** 
     * Create a new aspect
     * 
     * @param aspect The definition of the new aspect.
     */
    create(params: {  "aspect": AspectDefinition; }, options?: any) {
        return AspectDefinitionsApiFp.create(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a list of all aspects
     * 
     */
    getAll(options?: any) {
        return AspectDefinitionsApiFp.getAll(options)(this.fetch, this.basePath);
    }
    /** 
     * Get an aspect by ID
     * 
     * @param id ID of the aspect to be fetched.
     */
    getById(params: {  "id": string; }, options?: any) {
        return AspectDefinitionsApiFp.getById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Modify an aspect by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param id ID of the aspect to be saved.
     * @param aspectPatch The RFC 6902 patch to apply to the aspect.
     */
    patchById(params: {  "id": string; "aspectPatch": any; }, options?: any) {
        return AspectDefinitionsApiFp.patchById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Modify an aspect by ID
     * Modifies the aspect with a given ID.  If an aspect with the ID does not yet exist, it is created.
     * @param id ID of the aspect to be saved.
     * @param aspect The aspect to save.
     */
    putById(params: {  "id": string; "aspect": AspectDefinition; }, options?: any) {
        return AspectDefinitionsApiFp.putById(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AspectDefinitionsApi - factory interface
 */
export const AspectDefinitionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a new aspect
         * 
         * @param aspect The definition of the new aspect.
         */
        create(params: {  "aspect": AspectDefinition; }, options?: any) {
            return AspectDefinitionsApiFp.create(params, options)(fetch, basePath);
        },
        /** 
         * Get a list of all aspects
         * 
         */
        getAll(options?: any) {
            return AspectDefinitionsApiFp.getAll(options)(fetch, basePath);
        },
        /** 
         * Get an aspect by ID
         * 
         * @param id ID of the aspect to be fetched.
         */
        getById(params: {  "id": string; }, options?: any) {
            return AspectDefinitionsApiFp.getById(params, options)(fetch, basePath);
        },
        /** 
         * Modify an aspect by applying a JSON Patch
         * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
         * @param id ID of the aspect to be saved.
         * @param aspectPatch The RFC 6902 patch to apply to the aspect.
         */
        patchById(params: {  "id": string; "aspectPatch": any; }, options?: any) {
            return AspectDefinitionsApiFp.patchById(params, options)(fetch, basePath);
        },
        /** 
         * Modify an aspect by ID
         * Modifies the aspect with a given ID.  If an aspect with the ID does not yet exist, it is created.
         * @param id ID of the aspect to be saved.
         * @param aspect The aspect to save.
         */
        putById(params: {  "id": string; "aspect": AspectDefinition; }, options?: any) {
            return AspectDefinitionsApiFp.putById(params, options)(fetch, basePath);
        },
    };
};


/**
 * RecordAspectsApi - fetch parameter creator
 */
export const RecordAspectsApiFetchParamCreator = {
    /** 
     * Get a list of all aspects of a record
     * 
     * @param recordId ID of the record for which to fetch aspects.
     */
    getAll(params: {  "recordId": string; }, options?: any): FetchArgs {
        // verify required parameter "recordId" is set
        if (params["recordId"] == null) {
            throw new Error("Missing required parameter recordId when calling getAll");
        }
        const baseUrl = `/records/{recordId}/aspects`
            .replace(`{${"recordId"}}`, `${ params["recordId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a record aspect by ID
     * 
     * @param recordId ID of the record for which to fetch an aspect.
     * @param aspectId ID of the aspect to fetch.
     */
    getById(params: {  "recordId": string; "aspectId": string; }, options?: any): FetchArgs {
        // verify required parameter "recordId" is set
        if (params["recordId"] == null) {
            throw new Error("Missing required parameter recordId when calling getById");
        }
        // verify required parameter "aspectId" is set
        if (params["aspectId"] == null) {
            throw new Error("Missing required parameter aspectId when calling getById");
        }
        const baseUrl = `/records/{recordId}/aspects/{aspectId}`
            .replace(`{${"recordId"}}`, `${ params["recordId"] }`)
            .replace(`{${"aspectId"}}`, `${ params["aspectId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Modify a record aspect by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param recordId ID of the record for which to fetch an aspect.
     * @param aspectId ID of the aspect to fetch.
     * @param aspectPatch The RFC 6902 patch to apply to the aspect.
     */
    patchById(params: {  "recordId": string; "aspectId": string; "aspectPatch": any; }, options?: any): FetchArgs {
        // verify required parameter "recordId" is set
        if (params["recordId"] == null) {
            throw new Error("Missing required parameter recordId when calling patchById");
        }
        // verify required parameter "aspectId" is set
        if (params["aspectId"] == null) {
            throw new Error("Missing required parameter aspectId when calling patchById");
        }
        // verify required parameter "aspectPatch" is set
        if (params["aspectPatch"] == null) {
            throw new Error("Missing required parameter aspectPatch when calling patchById");
        }
        const baseUrl = `/records/{recordId}/aspects/{aspectId}`
            .replace(`{${"recordId"}}`, `${ params["recordId"] }`)
            .replace(`{${"aspectId"}}`, `${ params["aspectId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["aspectPatch"]) {
            fetchOptions.body = JSON.stringify(params["aspectPatch"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Modify a record aspect by ID
     * Modifies a record aspect.  If the aspect does not yet exist on this record, it is created.
     * @param recordId ID of the record for which to fetch an aspect.
     * @param aspectId ID of the aspect to fetch.
     * @param aspect The record aspect to save.
     */
    putById(params: {  "recordId": string; "aspectId": string; "aspect": any; }, options?: any): FetchArgs {
        // verify required parameter "recordId" is set
        if (params["recordId"] == null) {
            throw new Error("Missing required parameter recordId when calling putById");
        }
        // verify required parameter "aspectId" is set
        if (params["aspectId"] == null) {
            throw new Error("Missing required parameter aspectId when calling putById");
        }
        // verify required parameter "aspect" is set
        if (params["aspect"] == null) {
            throw new Error("Missing required parameter aspect when calling putById");
        }
        const baseUrl = `/records/{recordId}/aspects/{aspectId}`
            .replace(`{${"recordId"}}`, `${ params["recordId"] }`)
            .replace(`{${"aspectId"}}`, `${ params["aspectId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["aspect"]) {
            fetchOptions.body = JSON.stringify(params["aspect"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * RecordAspectsApi - functional programming interface
 */
export const RecordAspectsApiFp = {
    /** 
     * Get a list of all aspects of a record
     * 
     * @param recordId ID of the record for which to fetch aspects.
     */
    getAll(params: { "recordId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: any; }> {
        const fetchArgs = RecordAspectsApiFetchParamCreator.getAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a record aspect by ID
     * 
     * @param recordId ID of the record for which to fetch an aspect.
     * @param aspectId ID of the aspect to fetch.
     */
    getById(params: { "recordId": string; "aspectId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RecordAspectsApiFetchParamCreator.getById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Modify a record aspect by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param recordId ID of the record for which to fetch an aspect.
     * @param aspectId ID of the aspect to fetch.
     * @param aspectPatch The RFC 6902 patch to apply to the aspect.
     */
    patchById(params: { "recordId": string; "aspectId": string; "aspectPatch": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RecordAspectsApiFetchParamCreator.patchById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Modify a record aspect by ID
     * Modifies a record aspect.  If the aspect does not yet exist on this record, it is created.
     * @param recordId ID of the record for which to fetch an aspect.
     * @param aspectId ID of the aspect to fetch.
     * @param aspect The record aspect to save.
     */
    putById(params: { "recordId": string; "aspectId": string; "aspect": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RecordAspectsApiFetchParamCreator.putById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * RecordAspectsApi - object-oriented interface
 */
export class RecordAspectsApi extends BaseAPI {
    /** 
     * Get a list of all aspects of a record
     * 
     * @param recordId ID of the record for which to fetch aspects.
     */
    getAll(params: {  "recordId": string; }, options?: any) {
        return RecordAspectsApiFp.getAll(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a record aspect by ID
     * 
     * @param recordId ID of the record for which to fetch an aspect.
     * @param aspectId ID of the aspect to fetch.
     */
    getById(params: {  "recordId": string; "aspectId": string; }, options?: any) {
        return RecordAspectsApiFp.getById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Modify a record aspect by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param recordId ID of the record for which to fetch an aspect.
     * @param aspectId ID of the aspect to fetch.
     * @param aspectPatch The RFC 6902 patch to apply to the aspect.
     */
    patchById(params: {  "recordId": string; "aspectId": string; "aspectPatch": any; }, options?: any) {
        return RecordAspectsApiFp.patchById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Modify a record aspect by ID
     * Modifies a record aspect.  If the aspect does not yet exist on this record, it is created.
     * @param recordId ID of the record for which to fetch an aspect.
     * @param aspectId ID of the aspect to fetch.
     * @param aspect The record aspect to save.
     */
    putById(params: {  "recordId": string; "aspectId": string; "aspect": any; }, options?: any) {
        return RecordAspectsApiFp.putById(params, options)(this.fetch, this.basePath);
    }
};

/**
 * RecordAspectsApi - factory interface
 */
export const RecordAspectsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get a list of all aspects of a record
         * 
         * @param recordId ID of the record for which to fetch aspects.
         */
        getAll(params: {  "recordId": string; }, options?: any) {
            return RecordAspectsApiFp.getAll(params, options)(fetch, basePath);
        },
        /** 
         * Get a record aspect by ID
         * 
         * @param recordId ID of the record for which to fetch an aspect.
         * @param aspectId ID of the aspect to fetch.
         */
        getById(params: {  "recordId": string; "aspectId": string; }, options?: any) {
            return RecordAspectsApiFp.getById(params, options)(fetch, basePath);
        },
        /** 
         * Modify a record aspect by applying a JSON Patch
         * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
         * @param recordId ID of the record for which to fetch an aspect.
         * @param aspectId ID of the aspect to fetch.
         * @param aspectPatch The RFC 6902 patch to apply to the aspect.
         */
        patchById(params: {  "recordId": string; "aspectId": string; "aspectPatch": any; }, options?: any) {
            return RecordAspectsApiFp.patchById(params, options)(fetch, basePath);
        },
        /** 
         * Modify a record aspect by ID
         * Modifies a record aspect.  If the aspect does not yet exist on this record, it is created.
         * @param recordId ID of the record for which to fetch an aspect.
         * @param aspectId ID of the aspect to fetch.
         * @param aspect The record aspect to save.
         */
        putById(params: {  "recordId": string; "aspectId": string; "aspect": any; }, options?: any) {
            return RecordAspectsApiFp.putById(params, options)(fetch, basePath);
        },
    };
};


/**
 * RecordsApi - fetch parameter creator
 */
export const RecordsApiFetchParamCreator = {
    /** 
     * Create a new record
     * 
     * @param record The definition of the new record.
     */
    create(params: {  "record": Record; }, options?: any): FetchArgs {
        // verify required parameter "record" is set
        if (params["record"] == null) {
            throw new Error("Missing required parameter record when calling create");
        }
        const baseUrl = `/records`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["record"]) {
            fetchOptions.body = JSON.stringify(params["record"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a list of all records
     * 
     * @param aspect The aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  Only records that have at least one of these aspects will be included in the response.
     * @param aspects The aspects for which to retrieve data, specified as a comma-separate list.  Only records that have at least one of these aspects will be included in the response.
     */
    getAll(params: {  "aspect"?: Array<string>; "aspects"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/records`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "aspect": params["aspect"],
            "aspects": params["aspects"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a record by ID
     * Gets a complete record, including data for all aspects.
     * @param id ID of the record to be fetched.
     */
    getById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getById");
        }
        const baseUrl = `/records/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Modify a record by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param id ID of the aspect to be saved.
     * @param recordPatch The RFC 6902 patch to apply to the aspect.
     */
    patchById(params: {  "id": string; "recordPatch": any; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling patchById");
        }
        // verify required parameter "recordPatch" is set
        if (params["recordPatch"] == null) {
            throw new Error("Missing required parameter recordPatch when calling patchById");
        }
        const baseUrl = `/records/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["recordPatch"]) {
            fetchOptions.body = JSON.stringify(params["recordPatch"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Modify a record by ID
     * Modifies a record.  Aspects included in the request are created or updated, but missing aspects are not removed.
     * @param id ID of the record to be fetched.
     * @param record The record to save.
     */
    putById(params: {  "id": string; "record": Record; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling putById");
        }
        // verify required parameter "record" is set
        if (params["record"] == null) {
            throw new Error("Missing required parameter record when calling putById");
        }
        const baseUrl = `/records/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["record"]) {
            fetchOptions.body = JSON.stringify(params["record"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * RecordsApi - functional programming interface
 */
export const RecordsApiFp = {
    /** 
     * Create a new record
     * 
     * @param record The definition of the new record.
     */
    create(params: { "record": Record;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Record> {
        const fetchArgs = RecordsApiFetchParamCreator.create(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a list of all records
     * 
     * @param aspect The aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  Only records that have at least one of these aspects will be included in the response.
     * @param aspects The aspects for which to retrieve data, specified as a comma-separate list.  Only records that have at least one of these aspects will be included in the response.
     */
    getAll(params: { "aspect"?: Array<string>; "aspects"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RecordSummary>> {
        const fetchArgs = RecordsApiFetchParamCreator.getAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a record by ID
     * Gets a complete record, including data for all aspects.
     * @param id ID of the record to be fetched.
     */
    getById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Record> {
        const fetchArgs = RecordsApiFetchParamCreator.getById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Modify a record by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param id ID of the aspect to be saved.
     * @param recordPatch The RFC 6902 patch to apply to the aspect.
     */
    patchById(params: { "id": string; "recordPatch": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AspectDefinition> {
        const fetchArgs = RecordsApiFetchParamCreator.patchById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Modify a record by ID
     * Modifies a record.  Aspects included in the request are created or updated, but missing aspects are not removed.
     * @param id ID of the record to be fetched.
     * @param record The record to save.
     */
    putById(params: { "id": string; "record": Record;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Record> {
        const fetchArgs = RecordsApiFetchParamCreator.putById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * RecordsApi - object-oriented interface
 */
export class RecordsApi extends BaseAPI {
    /** 
     * Create a new record
     * 
     * @param record The definition of the new record.
     */
    create(params: {  "record": Record; }, options?: any) {
        return RecordsApiFp.create(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a list of all records
     * 
     * @param aspect The aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  Only records that have at least one of these aspects will be included in the response.
     * @param aspects The aspects for which to retrieve data, specified as a comma-separate list.  Only records that have at least one of these aspects will be included in the response.
     */
    getAll(params: {  "aspect"?: Array<string>; "aspects"?: string; }, options?: any) {
        return RecordsApiFp.getAll(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a record by ID
     * Gets a complete record, including data for all aspects.
     * @param id ID of the record to be fetched.
     */
    getById(params: {  "id": string; }, options?: any) {
        return RecordsApiFp.getById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Modify a record by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param id ID of the aspect to be saved.
     * @param recordPatch The RFC 6902 patch to apply to the aspect.
     */
    patchById(params: {  "id": string; "recordPatch": any; }, options?: any) {
        return RecordsApiFp.patchById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Modify a record by ID
     * Modifies a record.  Aspects included in the request are created or updated, but missing aspects are not removed.
     * @param id ID of the record to be fetched.
     * @param record The record to save.
     */
    putById(params: {  "id": string; "record": Record; }, options?: any) {
        return RecordsApiFp.putById(params, options)(this.fetch, this.basePath);
    }
};

/**
 * RecordsApi - factory interface
 */
export const RecordsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a new record
         * 
         * @param record The definition of the new record.
         */
        create(params: {  "record": Record; }, options?: any) {
            return RecordsApiFp.create(params, options)(fetch, basePath);
        },
        /** 
         * Get a list of all records
         * 
         * @param aspect The aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  Only records that have at least one of these aspects will be included in the response.
         * @param aspects The aspects for which to retrieve data, specified as a comma-separate list.  Only records that have at least one of these aspects will be included in the response.
         */
        getAll(params: {  "aspect"?: Array<string>; "aspects"?: string; }, options?: any) {
            return RecordsApiFp.getAll(params, options)(fetch, basePath);
        },
        /** 
         * Get a record by ID
         * Gets a complete record, including data for all aspects.
         * @param id ID of the record to be fetched.
         */
        getById(params: {  "id": string; }, options?: any) {
            return RecordsApiFp.getById(params, options)(fetch, basePath);
        },
        /** 
         * Modify a record by applying a JSON Patch
         * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
         * @param id ID of the aspect to be saved.
         * @param recordPatch The RFC 6902 patch to apply to the aspect.
         */
        patchById(params: {  "id": string; "recordPatch": any; }, options?: any) {
            return RecordsApiFp.patchById(params, options)(fetch, basePath);
        },
        /** 
         * Modify a record by ID
         * Modifies a record.  Aspects included in the request are created or updated, but missing aspects are not removed.
         * @param id ID of the record to be fetched.
         * @param record The record to save.
         */
        putById(params: {  "id": string; "record": Record; }, options?: any) {
            return RecordsApiFp.putById(params, options)(fetch, basePath);
        },
    };
};

