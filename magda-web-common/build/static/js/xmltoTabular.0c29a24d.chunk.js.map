{"version":3,"sources":["../static/js/xmltoTabular.0c29a24d.chunk.js","helpers/xmlToTabular.js","../node_modules/fast-xml-parser/bin/util.js","../node_modules/fast-xml-parser/bin/parser.js","../node_modules/fast-xml-parser/bin/validator.js","helpers/jsonToArray.js","../node_modules/traverse/index.js"],"names":["webpackJsonp","1704","module","__webpack_exports__","__webpack_require__","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_0_fast_xml_parser__","__WEBPACK_IMPORTED_MODULE_0_fast_xml_parser___default","n","__WEBPACK_IMPORTED_MODULE_1__jsonToArray__","xmlData","options","attrPrefix","textNodeName","ignoreNonTextNodeAttr","ignoreTextNodeAttr","ignoreNameSpace","ignoreRootElement","textNodeConversion","textAttrConversion","a","validate","jsonObj","parse","data","meta","fields","type","1766","exports","getAllMatches","string","regex","matches","match","exec","allmatches","index","length","push","doesMatch","undefined","doesNotMatch","1872","simplifyCDATA","cdata","result","cdRegx","val","i","resolveNameSpace","tagname","ignore","tags","split","prefix","charAt","parseValue","conversion","isNaN","indexOf","Number","parseFloat","parseInt","buildAttributesArr","attrStr","ignoreNS","trim","attrsRegx","attrs","xmlNode","parent","this","child","addChild","tagsRegx","RegExp","defaultOptions","arrayMode","buildOptions","props","getTraversalObj","xmlObj","currentNode","tag","nexttag","attrsStr","selfClosingTag","childNode","prop","hasOwnProperty","xml2json","convertToJson","node","jObj","obj","Array","isArray","swap","1873","validateTagName","util","startsWithXML","startsWith","validateAttributes","attrStrings","attrStringPattern","attrsList","attrPattern","attrNames","j","checkForMatchingTag","substring","nextIndex","tagsPattern","replace","1874","__WEBPACK_IMPORTED_MODULE_0_traverse__","__WEBPACK_IMPORTED_MODULE_0_traverse___default","reduce","acc","notRoot","isLeaf","name","key","1875","Traverse","walk","root","cb","immutable","path","parents","alive","walker","node_","updateState","state","keys","objectKeys","circular","notLeaf","isRoot","copy","modifiers","keepGoing","concat","slice","level","update","x","stopHere","delete","remove","splice","before","f","after","pre","post","stop","block","ret","call","forEach","isLast","isFirst","pop","src","dst","isDate","Date","getTime","isRegExp","isError","message","isBoolean","Boolean","isNumber","isString","String","create","getPrototypeOf","constructor","proto","prototype","__proto__","T","toS","toString","traverse","get","ps","has","set","map","init","skip","arguments","paths","nodes","clone","res","xs","fn","args","t","apply"],"mappings":"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","file":"static/js/xmltoTabular.0c29a24d.chunk.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 1704:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fast_xml_parser__ = __webpack_require__(1872);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fast_xml_parser___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_fast_xml_parser__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__jsonToArray__ = __webpack_require__(1874);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(xmlData){// when a tag has attributes\nvar options={attrPrefix:\"@_\",textNodeName:\"#text\",ignoreNonTextNodeAttr:true,ignoreTextNodeAttr:true,ignoreNameSpace:true,ignoreRootElement:false,textNodeConversion:true,textAttrConversion:false};if(__WEBPACK_IMPORTED_MODULE_0_fast_xml_parser___default.a.validate(xmlData)===true){//optional\nvar jsonObj=__WEBPACK_IMPORTED_MODULE_0_fast_xml_parser___default.a.parse(xmlData,options);var array=Object(__WEBPACK_IMPORTED_MODULE_1__jsonToArray__[\"a\" /* default */])(jsonObj);var data={data:array,meta:{fields:['name','value'],type:'tabular'}};return data;}return null;});\n\n/***/ }),\n\n/***/ 1766:\n/***/ (function(module, exports) {\n\nvar getAllMatches = function(string, regex) {\n  var matches = [];\n  var match = regex.exec(string);\n  while (match) {\n  \tvar allmatches = [];\n    for (var index = 0; index < match.length; index++) {\n  \t\tallmatches.push(match[index]);\n  \t}\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\n\nvar doesMatch = function(string,regex){\n  var match = regex.exec(string);\n  if(match === null || match === undefined) return false;\n  else return true;\n}\n\nvar doesNotMatch = function(string,regex){\n  return !doesMatch(string,regex);\n}\n\nexports.doesMatch = doesMatch\nexports.doesNotMatch = doesNotMatch\nexports.getAllMatches = getAllMatches;\n\n/***/ }),\n\n/***/ 1872:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getAllMatches = __webpack_require__(1766).getAllMatches;\n\nvar xmlNode = function(tagname,parent,val){\n    this.tagname = tagname;\n    this.parent = parent;\n    this.child = [];\n    this.val = val;\n    this.addChild = function (child){\n        this.child.push(child);\n    };\n};\n\n//var tagsRegx = new RegExp(\"<(\\\\/?[a-zA-Z0-9_:]+)([^>\\\\/]*)(\\\\/?)>([^<]+)?\",\"g\");\n//var tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:-]+)([^>]*)>([^<]+)?\",\"g\");\n//var cdataRegx = \"<!\\\\[CDATA\\\\[([^\\\\]\\\\]]*)\\\\]\\\\]>\";\nvar cdataRegx = \"<!\\\\[CDATA\\\\[(.*?)(\\\\]\\\\]>)\";\nvar tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\"+cdataRegx+\")*([^<]+)?\",\"g\");\n\nvar defaultOptions = {\n    attrPrefix : \"@_\",\n    textNodeName : \"#text\",\n    ignoreNonTextNodeAttr : true,\n    ignoreTextNodeAttr : true,\n    ignoreNameSpace : false,\n    ignoreRootElement : false,\n    textNodeConversion : true,\n    textAttrConversion : false,\n    arrayMode : false\n};\n\nvar buildOptions = function (options){\n    if(!options) options = {};\n    var props = [\"attrPrefix\",\"ignoreNonTextNodeAttr\",\"ignoreTextNodeAttr\",\"ignoreNameSpace\",\"ignoreRootElement\",\"textNodeName\",\"textNodeConversion\",\"textAttrConversion\",\"arrayMode\"];\n    for (var i = 0; i < props.length; i++) {\n        if(options[props[i]] === undefined){\n            options[props[i]] = defaultOptions[props[i]];\n        }\n    }\n    return options;\n};\n\nvar getTraversalObj =function (xmlData,options){\n    options = buildOptions(options);\n    //xmlData = xmlData.replace(/>(\\s+)/g, \">\");//Remove spaces and make it single line.\n    var tags = getAllMatches(xmlData,tagsRegx);\n    var xmlObj = new xmlNode('!xml');\n    var currentNode = xmlObj;\n\n    for (var i = 0; i < tags.length ; i++) {\n        var tag = resolveNameSpace(tags[i][1],options.ignoreNameSpace),\n            nexttag = i+1 < tags.length ? resolveNameSpace(tags[i+1][1],options.ignoreNameSpace) : undefined,\n            attrsStr = tags[i][2], attrs,\n            val = tags[i][4] ===  undefined ? tags[i][6] :  simplifyCDATA(tags[i][0]);\n        if(tag.indexOf(\"/\") === 0){//ending tag\n            currentNode = currentNode.parent;\n            continue;\n        }\n\n        var selfClosingTag = attrsStr.charAt(attrsStr.length-1) === '/';\n        var childNode = new xmlNode(tag,currentNode);\n\n        if(selfClosingTag){\n            attrs = buildAttributesArr(attrsStr,options.ignoreTextNodeAttr,options.attrPrefix,options.ignoreNameSpace,options.textAttrConversion);\n            childNode.val = attrs || \"\";\n            currentNode.addChild(childNode);\n        }else if( (\"/\" + tag) === nexttag){ //Text node\n            attrs = buildAttributesArr(attrsStr,options.ignoreTextNodeAttr,options.attrPrefix,options.ignoreNameSpace,options.textAttrConversion);\n            val = parseValue(val,options.textNodeConversion);\n            if(attrs){\n                attrs[options.textNodeName] = val;\n                childNode.val = attrs;\n            }else{\n                if(val !== undefined && val != null){\n                    childNode.val = val;    \n                }else{\n                    childNode.val = \"\";\n                }\n            }\n            currentNode.addChild(childNode);\n            i++;\n        }else{//starting tag\n            attrs = buildAttributesArr(attrsStr,options.ignoreNonTextNodeAttr,options.attrPrefix,options.ignoreNameSpace,options.textAttrConversion);\n            if(attrs){\n                for (var prop in attrs) {\n                  if(attrs.hasOwnProperty(prop)){\n                    childNode.addChild(new xmlNode(prop,childNode,attrs[prop]));\n                  }\n                }\n            }\n            currentNode.addChild(childNode);\n            currentNode = childNode;\n        }\n    }\n    return xmlObj;\n};\n\nvar xml2json = function (xmlData,options){\n    return convertToJson(getTraversalObj(xmlData,options), buildOptions(options).arrayMode);\n};\n\nvar cdRegx = new RegExp(cdataRegx,\"g\");\n\nfunction simplifyCDATA(cdata){\n    var result = getAllMatches(cdata,cdRegx);\n    var val = \"\";\n    for (var i = 0; i < result.length ; i++) {\n        val+=result[i][1];\n    }\n    return val;\n}\n\nfunction resolveNameSpace(tagname,ignore){\n    if(ignore){\n        var tags = tagname.split(\":\");\n        var prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if(tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n\nfunction parseValue(val,conversion){\n    if(val){\n        if(!conversion || isNaN(val)){\n            val = \"\" + val ;\n        }else{\n            if(val.indexOf(\".\") !== -1){\n                val = Number.parseFloat(val);\n            }else{\n                val = Number.parseInt(val,10);\n            }\n        }\n    }else{\n        val = \"\";\n    }\n    return val;\n}\n\n//var attrsRegx = new RegExp(\"(\\\\S+)=\\\\s*[\\\"']?((?:.(?![\\\"']?\\\\s+(?:\\\\S+)=|[>\\\"']))+.)[\\\"']?\",\"g\");\n//var attrsRegx = new RegExp(\"(\\\\S+)=\\\\s*(['\\\"])((?:.(?!\\\\2))*.)\",\"g\");\nvar attrsRegx = new RegExp(\"(\\\\S+)\\\\s*=\\\\s*(['\\\"])(.*?)\\\\2\",\"g\");\nfunction buildAttributesArr(attrStr,ignore,prefix,ignoreNS,conversion){\n    attrStr = attrStr || attrStr.trim();\n    \n    if(!ignore && attrStr.length > 3){\n\n        var matches = getAllMatches(attrStr,attrsRegx);\n        var attrs = {};\n        for (var i = 0; i < matches.length; i++) {\n            var attrName = prefix + resolveNameSpace( matches[i][1],ignoreNS);\n            attrs[attrName] = parseValue(matches[i][3],conversion);\n        }\n        return attrs;\n    }\n}\n\nvar convertToJson = function (node, arrayMode){\n    var jObj = {};\n    if(node.val !== undefined && node.val != null || node.val === \"\") {\n        return node.val;\n    }else{\n        for (var index = 0; index < node.child.length; index++) {\n            var prop = node.child[index].tagname;\n            var obj = convertToJson(node.child[index], arrayMode);\n            if(jObj[prop] !== undefined){\n                if(!Array.isArray(jObj[prop])){\n                    var swap = jObj[prop];\n                    jObj[prop] = [];\n                    jObj[prop].push(swap);\n                }\n                jObj[prop].push(obj);\n            }else{\n                jObj[prop] = arrayMode ? [obj] : obj;\n            }\n        }\n    }\n    return jObj;\n};\n\nexports.parse = xml2json;\nexports.getTraversalObj = getTraversalObj;\nexports.convertToJson = convertToJson;\nexports.validate = __webpack_require__(1873).validate;\n\n\n/***/ }),\n\n/***/ 1873:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar util = __webpack_require__(1766);\n\n\nvar tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function(xmlData){\n    xmlData = xmlData.replace(/\\n/g,\"\");//make it single line\n    xmlData = xmlData.replace(/(<!\\[CDATA\\[.*?\\]\\]>)/g,\"\");//Remove all CDATA\n    xmlData = xmlData.replace(/(<!--.*?(?:-->))/g,\"\");//Remove all comments\n    if(validateAttributes(xmlData) !== true) return false;\n    xmlData = xmlData.replace(/(\\s+(?:[\\w:\\-]+)\\s*=\\s*(['\\\"]).*?\\2)/g,\"\");//Remove all attributes\n    xmlData = xmlData.replace(/(^\\s*<\\?xml\\s*\\?>)/g,\"\");//Remove XML starting tag\n    if(xmlData.indexOf(\"<![CDATA[\") > 0 || xmlData.indexOf(\"<!--\") > 0 ) return false;\n    var tags = util.getAllMatches(xmlData,tagsPattern);\n    if(tags.length === 0) return false; //non xml string\n    \n    var result = checkForMatchingTag(tags,0);\n    \n\n    if(result !== true) return false; else return true; \n    \n}\n\n\nvar startsWithXML = new RegExp(\"^[Xx][Mm][Ll]\");\nvar startsWith = new RegExp(\"^([a-zA-Z]|_)[\\\\w\\.\\\\-_:]*\");\n\nfunction validateTagName(tagname){\n    if(util.doesMatch(tagname,startsWithXML)) return false;\n    else if(util.doesNotMatch(tagname,startsWith)) return false;\n    else return true;\n}\n\nvar attrStringPattern = new RegExp(\"<[\\\\w:\\\\-_\\.]+(.*?)\\/?>\",\"g\");\nvar attrPattern = new RegExp(\"\\\\s+([\\\\w:\\-]+)\\\\s*=\\\\s*(['\\\"])(.*?)\\\\2\",\"g\");\nfunction validateAttributes(xmlData){\n    var attrStrings = util.getAllMatches(xmlData,attrStringPattern);\n    for (i=0;i<attrStrings.length;i++){\n        if(attrStrings[i][1].trim().length > 0 && attrStrings[i][1].trim().length < 4){ //invalid attributes \n            return false;\n        }else if(attrStrings[i][1].trim().length !== 0){\n            var attrsList = util.getAllMatches(attrStrings[i][1],attrPattern);\n            var attrNames=[];\n            for (j=0;j<attrsList.length;j++){\n                if(attrNames.hasOwnProperty(attrsList[j][1])){//duplicate attributes\n                    return false;\n                }else{\n                    attrNames[attrsList[j][1]]=1;\n                    //validate attribute value\n                    //if(!validateAttrValue(attrsList[3])) return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\nfunction checkForMatchingTag(tags,i){\n    if(tags.length === i) {\n        return true;\n    }else if(tags[i][0].indexOf(\"</\") === 0) {//closing tag\n        return i;\n    }else if(tags[i][0].indexOf(\"/>\") === tags[i][0].length-2){//Self closing tag\n        if(validateTagName(tags[i][0].substring(1)) === false) return -1;\n        return checkForMatchingTag(tags,i+1);\n\n    }else if(tags.length > i+1){\n        if(tags[i+1][0].indexOf(\"</\") === 0){//next tag\n            if(validateTagName(tags[i][1]) === false) return -1;\n            if(tags[i][1] === tags[i+1][1]) {//matching with next closing tag\n                return checkForMatchingTag(tags,i+2);\n            }else {\n                return -1;//not matching\n            }\n        }else\n            var nextIndex = checkForMatchingTag(tags,i+1);\n            if(nextIndex !== -1 && tags[nextIndex][0].indexOf(\"</\") === 0){\n                if(validateTagName(tags[i][1]) === false) return -1;\n                if(tags[i][1] === tags[nextIndex][1]) {\n                    return checkForMatchingTag(tags,nextIndex+1);\n                }else {\n                    return -1;//not matching\n                }\n            }\n    }\n    return -1;\n}\n\n\n\n/***/ }),\n\n/***/ 1874:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_traverse__ = __webpack_require__(1875);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_traverse___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_traverse__);\n/* harmony default export */ __webpack_exports__[\"a\"] = (function(jsonObj){var array=__WEBPACK_IMPORTED_MODULE_0_traverse___default()(jsonObj).reduce(function(acc){if(this.notRoot&&this.isLeaf){acc.push({name:this.parent.key,value:this.node});}return acc;},[]);return array;});\n\n/***/ }),\n\n/***/ 1875:\n/***/ (function(module, exports) {\n\nvar traverse = module.exports = function (obj) {\n    return new Traverse(obj);\n};\n\nfunction Traverse (obj) {\n    this.value = obj;\n}\n\nTraverse.prototype.get = function (ps) {\n    var node = this.value;\n    for (var i = 0; i < ps.length; i ++) {\n        var key = ps[i];\n        if (!node || !hasOwnProperty.call(node, key)) {\n            node = undefined;\n            break;\n        }\n        node = node[key];\n    }\n    return node;\n};\n\nTraverse.prototype.has = function (ps) {\n    var node = this.value;\n    for (var i = 0; i < ps.length; i ++) {\n        var key = ps[i];\n        if (!node || !hasOwnProperty.call(node, key)) {\n            return false;\n        }\n        node = node[key];\n    }\n    return true;\n};\n\nTraverse.prototype.set = function (ps, value) {\n    var node = this.value;\n    for (var i = 0; i < ps.length - 1; i ++) {\n        var key = ps[i];\n        if (!hasOwnProperty.call(node, key)) node[key] = {};\n        node = node[key];\n    }\n    node[ps[i]] = value;\n    return value;\n};\n\nTraverse.prototype.map = function (cb) {\n    return walk(this.value, cb, true);\n};\n\nTraverse.prototype.forEach = function (cb) {\n    this.value = walk(this.value, cb, false);\n    return this.value;\n};\n\nTraverse.prototype.reduce = function (cb, init) {\n    var skip = arguments.length === 1;\n    var acc = skip ? this.value : init;\n    this.forEach(function (x) {\n        if (!this.isRoot || !skip) {\n            acc = cb.call(this, acc, x);\n        }\n    });\n    return acc;\n};\n\nTraverse.prototype.paths = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.path); \n    });\n    return acc;\n};\n\nTraverse.prototype.nodes = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.node);\n    });\n    return acc;\n};\n\nTraverse.prototype.clone = function () {\n    var parents = [], nodes = [];\n    \n    return (function clone (src) {\n        for (var i = 0; i < parents.length; i++) {\n            if (parents[i] === src) {\n                return nodes[i];\n            }\n        }\n        \n        if (typeof src === 'object' && src !== null) {\n            var dst = copy(src);\n            \n            parents.push(src);\n            nodes.push(dst);\n            \n            forEach(objectKeys(src), function (key) {\n                dst[key] = clone(src[key]);\n            });\n            \n            parents.pop();\n            nodes.pop();\n            return dst;\n        }\n        else {\n            return src;\n        }\n    })(this.value);\n};\n\nfunction walk (root, cb, immutable) {\n    var path = [];\n    var parents = [];\n    var alive = true;\n    \n    return (function walker (node_) {\n        var node = immutable ? copy(node_) : node_;\n        var modifiers = {};\n        \n        var keepGoing = true;\n        \n        var state = {\n            node : node,\n            node_ : node_,\n            path : [].concat(path),\n            parent : parents[parents.length - 1],\n            parents : parents,\n            key : path.slice(-1)[0],\n            isRoot : path.length === 0,\n            level : path.length,\n            circular : null,\n            update : function (x, stopHere) {\n                if (!state.isRoot) {\n                    state.parent.node[state.key] = x;\n                }\n                state.node = x;\n                if (stopHere) keepGoing = false;\n            },\n            'delete' : function (stopHere) {\n                delete state.parent.node[state.key];\n                if (stopHere) keepGoing = false;\n            },\n            remove : function (stopHere) {\n                if (isArray(state.parent.node)) {\n                    state.parent.node.splice(state.key, 1);\n                }\n                else {\n                    delete state.parent.node[state.key];\n                }\n                if (stopHere) keepGoing = false;\n            },\n            keys : null,\n            before : function (f) { modifiers.before = f },\n            after : function (f) { modifiers.after = f },\n            pre : function (f) { modifiers.pre = f },\n            post : function (f) { modifiers.post = f },\n            stop : function () { alive = false },\n            block : function () { keepGoing = false }\n        };\n        \n        if (!alive) return state;\n        \n        function updateState() {\n            if (typeof state.node === 'object' && state.node !== null) {\n                if (!state.keys || state.node_ !== state.node) {\n                    state.keys = objectKeys(state.node)\n                }\n                \n                state.isLeaf = state.keys.length == 0;\n                \n                for (var i = 0; i < parents.length; i++) {\n                    if (parents[i].node_ === node_) {\n                        state.circular = parents[i];\n                        break;\n                    }\n                }\n            }\n            else {\n                state.isLeaf = true;\n                state.keys = null;\n            }\n            \n            state.notLeaf = !state.isLeaf;\n            state.notRoot = !state.isRoot;\n        }\n        \n        updateState();\n        \n        // use return values to update if defined\n        var ret = cb.call(state, state.node);\n        if (ret !== undefined && state.update) state.update(ret);\n        \n        if (modifiers.before) modifiers.before.call(state, state.node);\n        \n        if (!keepGoing) return state;\n        \n        if (typeof state.node == 'object'\n        && state.node !== null && !state.circular) {\n            parents.push(state);\n            \n            updateState();\n            \n            forEach(state.keys, function (key, i) {\n                path.push(key);\n                \n                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);\n                \n                var child = walker(state.node[key]);\n                if (immutable && hasOwnProperty.call(state.node, key)) {\n                    state.node[key] = child.node;\n                }\n                \n                child.isLast = i == state.keys.length - 1;\n                child.isFirst = i == 0;\n                \n                if (modifiers.post) modifiers.post.call(state, child);\n                \n                path.pop();\n            });\n            parents.pop();\n        }\n        \n        if (modifiers.after) modifiers.after.call(state, state.node);\n        \n        return state;\n    })(root).node;\n}\n\nfunction copy (src) {\n    if (typeof src === 'object' && src !== null) {\n        var dst;\n        \n        if (isArray(src)) {\n            dst = [];\n        }\n        else if (isDate(src)) {\n            dst = new Date(src.getTime ? src.getTime() : src);\n        }\n        else if (isRegExp(src)) {\n            dst = new RegExp(src);\n        }\n        else if (isError(src)) {\n            dst = { message: src.message };\n        }\n        else if (isBoolean(src)) {\n            dst = new Boolean(src);\n        }\n        else if (isNumber(src)) {\n            dst = new Number(src);\n        }\n        else if (isString(src)) {\n            dst = new String(src);\n        }\n        else if (Object.create && Object.getPrototypeOf) {\n            dst = Object.create(Object.getPrototypeOf(src));\n        }\n        else if (src.constructor === Object) {\n            dst = {};\n        }\n        else {\n            var proto =\n                (src.constructor && src.constructor.prototype)\n                || src.__proto__\n                || {}\n            ;\n            var T = function () {};\n            T.prototype = proto;\n            dst = new T;\n        }\n        \n        forEach(objectKeys(src), function (key) {\n            dst[key] = src[key];\n        });\n        return dst;\n    }\n    else return src;\n}\n\nvar objectKeys = Object.keys || function keys (obj) {\n    var res = [];\n    for (var key in obj) res.push(key)\n    return res;\n};\n\nfunction toS (obj) { return Object.prototype.toString.call(obj) }\nfunction isDate (obj) { return toS(obj) === '[object Date]' }\nfunction isRegExp (obj) { return toS(obj) === '[object RegExp]' }\nfunction isError (obj) { return toS(obj) === '[object Error]' }\nfunction isBoolean (obj) { return toS(obj) === '[object Boolean]' }\nfunction isNumber (obj) { return toS(obj) === '[object Number]' }\nfunction isString (obj) { return toS(obj) === '[object String]' }\n\nvar isArray = Array.isArray || function isArray (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nforEach(objectKeys(Traverse.prototype), function (key) {\n    traverse[key] = function (obj) {\n        var args = [].slice.call(arguments, 1);\n        var t = new Traverse(obj);\n        return t[key].apply(t, args);\n    };\n});\n\nvar hasOwnProperty = Object.hasOwnProperty || function (obj, key) {\n    return key in obj;\n};\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/xmltoTabular.0c29a24d.chunk.js","//@flow\nimport  fastXmlParser from 'fast-xml-parser';\nimport jsonToArray from './jsonToArray';\nimport type {PreviewData} from './previewData';\n\nexport default function(xmlData: string){\n  // when a tag has attributes\n    const options = {\n        attrPrefix : \"@_\",\n        textNodeName : \"#text\",\n        ignoreNonTextNodeAttr : true,\n        ignoreTextNodeAttr : true,\n        ignoreNameSpace : true,\n        ignoreRootElement : false,\n        textNodeConversion : true,\n        textAttrConversion : false\n    };\n    if(fastXmlParser.validate(xmlData)=== true){\n      //optional\n      const jsonObj = fastXmlParser.parse(xmlData,options);\n      var array = jsonToArray(jsonObj);\n      const data: PreviewData = {\n        data: array,\n        meta: {\n          fields: ['name', 'value'],\n          type: 'tabular'\n        }\n      }\n      return data\n    }\n    return null;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/xmlToTabular.js","var getAllMatches = function(string, regex) {\n  var matches = [];\n  var match = regex.exec(string);\n  while (match) {\n  \tvar allmatches = [];\n    for (var index = 0; index < match.length; index++) {\n  \t\tallmatches.push(match[index]);\n  \t}\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\n\nvar doesMatch = function(string,regex){\n  var match = regex.exec(string);\n  if(match === null || match === undefined) return false;\n  else return true;\n}\n\nvar doesNotMatch = function(string,regex){\n  return !doesMatch(string,regex);\n}\n\nexports.doesMatch = doesMatch\nexports.doesNotMatch = doesNotMatch\nexports.getAllMatches = getAllMatches;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/fast-xml-parser/bin/util.js\n// module id = 1766\n// module chunks = 1","var getAllMatches = require(\"./util\").getAllMatches;\n\nvar xmlNode = function(tagname,parent,val){\n    this.tagname = tagname;\n    this.parent = parent;\n    this.child = [];\n    this.val = val;\n    this.addChild = function (child){\n        this.child.push(child);\n    };\n};\n\n//var tagsRegx = new RegExp(\"<(\\\\/?[a-zA-Z0-9_:]+)([^>\\\\/]*)(\\\\/?)>([^<]+)?\",\"g\");\n//var tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:-]+)([^>]*)>([^<]+)?\",\"g\");\n//var cdataRegx = \"<!\\\\[CDATA\\\\[([^\\\\]\\\\]]*)\\\\]\\\\]>\";\nvar cdataRegx = \"<!\\\\[CDATA\\\\[(.*?)(\\\\]\\\\]>)\";\nvar tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\"+cdataRegx+\")*([^<]+)?\",\"g\");\n\nvar defaultOptions = {\n    attrPrefix : \"@_\",\n    textNodeName : \"#text\",\n    ignoreNonTextNodeAttr : true,\n    ignoreTextNodeAttr : true,\n    ignoreNameSpace : false,\n    ignoreRootElement : false,\n    textNodeConversion : true,\n    textAttrConversion : false,\n    arrayMode : false\n};\n\nvar buildOptions = function (options){\n    if(!options) options = {};\n    var props = [\"attrPrefix\",\"ignoreNonTextNodeAttr\",\"ignoreTextNodeAttr\",\"ignoreNameSpace\",\"ignoreRootElement\",\"textNodeName\",\"textNodeConversion\",\"textAttrConversion\",\"arrayMode\"];\n    for (var i = 0; i < props.length; i++) {\n        if(options[props[i]] === undefined){\n            options[props[i]] = defaultOptions[props[i]];\n        }\n    }\n    return options;\n};\n\nvar getTraversalObj =function (xmlData,options){\n    options = buildOptions(options);\n    //xmlData = xmlData.replace(/>(\\s+)/g, \">\");//Remove spaces and make it single line.\n    var tags = getAllMatches(xmlData,tagsRegx);\n    var xmlObj = new xmlNode('!xml');\n    var currentNode = xmlObj;\n\n    for (var i = 0; i < tags.length ; i++) {\n        var tag = resolveNameSpace(tags[i][1],options.ignoreNameSpace),\n            nexttag = i+1 < tags.length ? resolveNameSpace(tags[i+1][1],options.ignoreNameSpace) : undefined,\n            attrsStr = tags[i][2], attrs,\n            val = tags[i][4] ===  undefined ? tags[i][6] :  simplifyCDATA(tags[i][0]);\n        if(tag.indexOf(\"/\") === 0){//ending tag\n            currentNode = currentNode.parent;\n            continue;\n        }\n\n        var selfClosingTag = attrsStr.charAt(attrsStr.length-1) === '/';\n        var childNode = new xmlNode(tag,currentNode);\n\n        if(selfClosingTag){\n            attrs = buildAttributesArr(attrsStr,options.ignoreTextNodeAttr,options.attrPrefix,options.ignoreNameSpace,options.textAttrConversion);\n            childNode.val = attrs || \"\";\n            currentNode.addChild(childNode);\n        }else if( (\"/\" + tag) === nexttag){ //Text node\n            attrs = buildAttributesArr(attrsStr,options.ignoreTextNodeAttr,options.attrPrefix,options.ignoreNameSpace,options.textAttrConversion);\n            val = parseValue(val,options.textNodeConversion);\n            if(attrs){\n                attrs[options.textNodeName] = val;\n                childNode.val = attrs;\n            }else{\n                if(val !== undefined && val != null){\n                    childNode.val = val;    \n                }else{\n                    childNode.val = \"\";\n                }\n            }\n            currentNode.addChild(childNode);\n            i++;\n        }else{//starting tag\n            attrs = buildAttributesArr(attrsStr,options.ignoreNonTextNodeAttr,options.attrPrefix,options.ignoreNameSpace,options.textAttrConversion);\n            if(attrs){\n                for (var prop in attrs) {\n                  if(attrs.hasOwnProperty(prop)){\n                    childNode.addChild(new xmlNode(prop,childNode,attrs[prop]));\n                  }\n                }\n            }\n            currentNode.addChild(childNode);\n            currentNode = childNode;\n        }\n    }\n    return xmlObj;\n};\n\nvar xml2json = function (xmlData,options){\n    return convertToJson(getTraversalObj(xmlData,options), buildOptions(options).arrayMode);\n};\n\nvar cdRegx = new RegExp(cdataRegx,\"g\");\n\nfunction simplifyCDATA(cdata){\n    var result = getAllMatches(cdata,cdRegx);\n    var val = \"\";\n    for (var i = 0; i < result.length ; i++) {\n        val+=result[i][1];\n    }\n    return val;\n}\n\nfunction resolveNameSpace(tagname,ignore){\n    if(ignore){\n        var tags = tagname.split(\":\");\n        var prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if(tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n\nfunction parseValue(val,conversion){\n    if(val){\n        if(!conversion || isNaN(val)){\n            val = \"\" + val ;\n        }else{\n            if(val.indexOf(\".\") !== -1){\n                val = Number.parseFloat(val);\n            }else{\n                val = Number.parseInt(val,10);\n            }\n        }\n    }else{\n        val = \"\";\n    }\n    return val;\n}\n\n//var attrsRegx = new RegExp(\"(\\\\S+)=\\\\s*[\\\"']?((?:.(?![\\\"']?\\\\s+(?:\\\\S+)=|[>\\\"']))+.)[\\\"']?\",\"g\");\n//var attrsRegx = new RegExp(\"(\\\\S+)=\\\\s*(['\\\"])((?:.(?!\\\\2))*.)\",\"g\");\nvar attrsRegx = new RegExp(\"(\\\\S+)\\\\s*=\\\\s*(['\\\"])(.*?)\\\\2\",\"g\");\nfunction buildAttributesArr(attrStr,ignore,prefix,ignoreNS,conversion){\n    attrStr = attrStr || attrStr.trim();\n    \n    if(!ignore && attrStr.length > 3){\n\n        var matches = getAllMatches(attrStr,attrsRegx);\n        var attrs = {};\n        for (var i = 0; i < matches.length; i++) {\n            var attrName = prefix + resolveNameSpace( matches[i][1],ignoreNS);\n            attrs[attrName] = parseValue(matches[i][3],conversion);\n        }\n        return attrs;\n    }\n}\n\nvar convertToJson = function (node, arrayMode){\n    var jObj = {};\n    if(node.val !== undefined && node.val != null || node.val === \"\") {\n        return node.val;\n    }else{\n        for (var index = 0; index < node.child.length; index++) {\n            var prop = node.child[index].tagname;\n            var obj = convertToJson(node.child[index], arrayMode);\n            if(jObj[prop] !== undefined){\n                if(!Array.isArray(jObj[prop])){\n                    var swap = jObj[prop];\n                    jObj[prop] = [];\n                    jObj[prop].push(swap);\n                }\n                jObj[prop].push(obj);\n            }else{\n                jObj[prop] = arrayMode ? [obj] : obj;\n            }\n        }\n    }\n    return jObj;\n};\n\nexports.parse = xml2json;\nexports.getTraversalObj = getTraversalObj;\nexports.convertToJson = convertToJson;\nexports.validate = require(\"./validator\").validate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/fast-xml-parser/bin/parser.js\n// module id = 1872\n// module chunks = 1","var util = require(\"./util\");\n\n\nvar tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function(xmlData){\n    xmlData = xmlData.replace(/\\n/g,\"\");//make it single line\n    xmlData = xmlData.replace(/(<!\\[CDATA\\[.*?\\]\\]>)/g,\"\");//Remove all CDATA\n    xmlData = xmlData.replace(/(<!--.*?(?:-->))/g,\"\");//Remove all comments\n    if(validateAttributes(xmlData) !== true) return false;\n    xmlData = xmlData.replace(/(\\s+(?:[\\w:\\-]+)\\s*=\\s*(['\\\"]).*?\\2)/g,\"\");//Remove all attributes\n    xmlData = xmlData.replace(/(^\\s*<\\?xml\\s*\\?>)/g,\"\");//Remove XML starting tag\n    if(xmlData.indexOf(\"<![CDATA[\") > 0 || xmlData.indexOf(\"<!--\") > 0 ) return false;\n    var tags = util.getAllMatches(xmlData,tagsPattern);\n    if(tags.length === 0) return false; //non xml string\n    \n    var result = checkForMatchingTag(tags,0);\n    \n\n    if(result !== true) return false; else return true; \n    \n}\n\n\nvar startsWithXML = new RegExp(\"^[Xx][Mm][Ll]\");\nvar startsWith = new RegExp(\"^([a-zA-Z]|_)[\\\\w\\.\\\\-_:]*\");\n\nfunction validateTagName(tagname){\n    if(util.doesMatch(tagname,startsWithXML)) return false;\n    else if(util.doesNotMatch(tagname,startsWith)) return false;\n    else return true;\n}\n\nvar attrStringPattern = new RegExp(\"<[\\\\w:\\\\-_\\.]+(.*?)\\/?>\",\"g\");\nvar attrPattern = new RegExp(\"\\\\s+([\\\\w:\\-]+)\\\\s*=\\\\s*(['\\\"])(.*?)\\\\2\",\"g\");\nfunction validateAttributes(xmlData){\n    var attrStrings = util.getAllMatches(xmlData,attrStringPattern);\n    for (i=0;i<attrStrings.length;i++){\n        if(attrStrings[i][1].trim().length > 0 && attrStrings[i][1].trim().length < 4){ //invalid attributes \n            return false;\n        }else if(attrStrings[i][1].trim().length !== 0){\n            var attrsList = util.getAllMatches(attrStrings[i][1],attrPattern);\n            var attrNames=[];\n            for (j=0;j<attrsList.length;j++){\n                if(attrNames.hasOwnProperty(attrsList[j][1])){//duplicate attributes\n                    return false;\n                }else{\n                    attrNames[attrsList[j][1]]=1;\n                    //validate attribute value\n                    //if(!validateAttrValue(attrsList[3])) return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\nfunction checkForMatchingTag(tags,i){\n    if(tags.length === i) {\n        return true;\n    }else if(tags[i][0].indexOf(\"</\") === 0) {//closing tag\n        return i;\n    }else if(tags[i][0].indexOf(\"/>\") === tags[i][0].length-2){//Self closing tag\n        if(validateTagName(tags[i][0].substring(1)) === false) return -1;\n        return checkForMatchingTag(tags,i+1);\n\n    }else if(tags.length > i+1){\n        if(tags[i+1][0].indexOf(\"</\") === 0){//next tag\n            if(validateTagName(tags[i][1]) === false) return -1;\n            if(tags[i][1] === tags[i+1][1]) {//matching with next closing tag\n                return checkForMatchingTag(tags,i+2);\n            }else {\n                return -1;//not matching\n            }\n        }else\n            var nextIndex = checkForMatchingTag(tags,i+1);\n            if(nextIndex !== -1 && tags[nextIndex][0].indexOf(\"</\") === 0){\n                if(validateTagName(tags[i][1]) === false) return -1;\n                if(tags[i][1] === tags[nextIndex][1]) {\n                    return checkForMatchingTag(tags,nextIndex+1);\n                }else {\n                    return -1;//not matching\n                }\n            }\n    }\n    return -1;\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/fast-xml-parser/bin/validator.js\n// module id = 1873\n// module chunks = 1","//@flow\nimport traverse from 'traverse';\n\nexport default function(jsonObj: Object){\n  const array = traverse(jsonObj).reduce(function (acc) {\n      if (this.notRoot && this.isLeaf) {\n        acc.push(\n          {\n            name:this.parent.key,\n            value:this.node\n          }\n        );\n      }\n      return acc;\n  }, []);\n  return array;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/jsonToArray.js","var traverse = module.exports = function (obj) {\n    return new Traverse(obj);\n};\n\nfunction Traverse (obj) {\n    this.value = obj;\n}\n\nTraverse.prototype.get = function (ps) {\n    var node = this.value;\n    for (var i = 0; i < ps.length; i ++) {\n        var key = ps[i];\n        if (!node || !hasOwnProperty.call(node, key)) {\n            node = undefined;\n            break;\n        }\n        node = node[key];\n    }\n    return node;\n};\n\nTraverse.prototype.has = function (ps) {\n    var node = this.value;\n    for (var i = 0; i < ps.length; i ++) {\n        var key = ps[i];\n        if (!node || !hasOwnProperty.call(node, key)) {\n            return false;\n        }\n        node = node[key];\n    }\n    return true;\n};\n\nTraverse.prototype.set = function (ps, value) {\n    var node = this.value;\n    for (var i = 0; i < ps.length - 1; i ++) {\n        var key = ps[i];\n        if (!hasOwnProperty.call(node, key)) node[key] = {};\n        node = node[key];\n    }\n    node[ps[i]] = value;\n    return value;\n};\n\nTraverse.prototype.map = function (cb) {\n    return walk(this.value, cb, true);\n};\n\nTraverse.prototype.forEach = function (cb) {\n    this.value = walk(this.value, cb, false);\n    return this.value;\n};\n\nTraverse.prototype.reduce = function (cb, init) {\n    var skip = arguments.length === 1;\n    var acc = skip ? this.value : init;\n    this.forEach(function (x) {\n        if (!this.isRoot || !skip) {\n            acc = cb.call(this, acc, x);\n        }\n    });\n    return acc;\n};\n\nTraverse.prototype.paths = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.path); \n    });\n    return acc;\n};\n\nTraverse.prototype.nodes = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.node);\n    });\n    return acc;\n};\n\nTraverse.prototype.clone = function () {\n    var parents = [], nodes = [];\n    \n    return (function clone (src) {\n        for (var i = 0; i < parents.length; i++) {\n            if (parents[i] === src) {\n                return nodes[i];\n            }\n        }\n        \n        if (typeof src === 'object' && src !== null) {\n            var dst = copy(src);\n            \n            parents.push(src);\n            nodes.push(dst);\n            \n            forEach(objectKeys(src), function (key) {\n                dst[key] = clone(src[key]);\n            });\n            \n            parents.pop();\n            nodes.pop();\n            return dst;\n        }\n        else {\n            return src;\n        }\n    })(this.value);\n};\n\nfunction walk (root, cb, immutable) {\n    var path = [];\n    var parents = [];\n    var alive = true;\n    \n    return (function walker (node_) {\n        var node = immutable ? copy(node_) : node_;\n        var modifiers = {};\n        \n        var keepGoing = true;\n        \n        var state = {\n            node : node,\n            node_ : node_,\n            path : [].concat(path),\n            parent : parents[parents.length - 1],\n            parents : parents,\n            key : path.slice(-1)[0],\n            isRoot : path.length === 0,\n            level : path.length,\n            circular : null,\n            update : function (x, stopHere) {\n                if (!state.isRoot) {\n                    state.parent.node[state.key] = x;\n                }\n                state.node = x;\n                if (stopHere) keepGoing = false;\n            },\n            'delete' : function (stopHere) {\n                delete state.parent.node[state.key];\n                if (stopHere) keepGoing = false;\n            },\n            remove : function (stopHere) {\n                if (isArray(state.parent.node)) {\n                    state.parent.node.splice(state.key, 1);\n                }\n                else {\n                    delete state.parent.node[state.key];\n                }\n                if (stopHere) keepGoing = false;\n            },\n            keys : null,\n            before : function (f) { modifiers.before = f },\n            after : function (f) { modifiers.after = f },\n            pre : function (f) { modifiers.pre = f },\n            post : function (f) { modifiers.post = f },\n            stop : function () { alive = false },\n            block : function () { keepGoing = false }\n        };\n        \n        if (!alive) return state;\n        \n        function updateState() {\n            if (typeof state.node === 'object' && state.node !== null) {\n                if (!state.keys || state.node_ !== state.node) {\n                    state.keys = objectKeys(state.node)\n                }\n                \n                state.isLeaf = state.keys.length == 0;\n                \n                for (var i = 0; i < parents.length; i++) {\n                    if (parents[i].node_ === node_) {\n                        state.circular = parents[i];\n                        break;\n                    }\n                }\n            }\n            else {\n                state.isLeaf = true;\n                state.keys = null;\n            }\n            \n            state.notLeaf = !state.isLeaf;\n            state.notRoot = !state.isRoot;\n        }\n        \n        updateState();\n        \n        // use return values to update if defined\n        var ret = cb.call(state, state.node);\n        if (ret !== undefined && state.update) state.update(ret);\n        \n        if (modifiers.before) modifiers.before.call(state, state.node);\n        \n        if (!keepGoing) return state;\n        \n        if (typeof state.node == 'object'\n        && state.node !== null && !state.circular) {\n            parents.push(state);\n            \n            updateState();\n            \n            forEach(state.keys, function (key, i) {\n                path.push(key);\n                \n                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);\n                \n                var child = walker(state.node[key]);\n                if (immutable && hasOwnProperty.call(state.node, key)) {\n                    state.node[key] = child.node;\n                }\n                \n                child.isLast = i == state.keys.length - 1;\n                child.isFirst = i == 0;\n                \n                if (modifiers.post) modifiers.post.call(state, child);\n                \n                path.pop();\n            });\n            parents.pop();\n        }\n        \n        if (modifiers.after) modifiers.after.call(state, state.node);\n        \n        return state;\n    })(root).node;\n}\n\nfunction copy (src) {\n    if (typeof src === 'object' && src !== null) {\n        var dst;\n        \n        if (isArray(src)) {\n            dst = [];\n        }\n        else if (isDate(src)) {\n            dst = new Date(src.getTime ? src.getTime() : src);\n        }\n        else if (isRegExp(src)) {\n            dst = new RegExp(src);\n        }\n        else if (isError(src)) {\n            dst = { message: src.message };\n        }\n        else if (isBoolean(src)) {\n            dst = new Boolean(src);\n        }\n        else if (isNumber(src)) {\n            dst = new Number(src);\n        }\n        else if (isString(src)) {\n            dst = new String(src);\n        }\n        else if (Object.create && Object.getPrototypeOf) {\n            dst = Object.create(Object.getPrototypeOf(src));\n        }\n        else if (src.constructor === Object) {\n            dst = {};\n        }\n        else {\n            var proto =\n                (src.constructor && src.constructor.prototype)\n                || src.__proto__\n                || {}\n            ;\n            var T = function () {};\n            T.prototype = proto;\n            dst = new T;\n        }\n        \n        forEach(objectKeys(src), function (key) {\n            dst[key] = src[key];\n        });\n        return dst;\n    }\n    else return src;\n}\n\nvar objectKeys = Object.keys || function keys (obj) {\n    var res = [];\n    for (var key in obj) res.push(key)\n    return res;\n};\n\nfunction toS (obj) { return Object.prototype.toString.call(obj) }\nfunction isDate (obj) { return toS(obj) === '[object Date]' }\nfunction isRegExp (obj) { return toS(obj) === '[object RegExp]' }\nfunction isError (obj) { return toS(obj) === '[object Error]' }\nfunction isBoolean (obj) { return toS(obj) === '[object Boolean]' }\nfunction isNumber (obj) { return toS(obj) === '[object Number]' }\nfunction isString (obj) { return toS(obj) === '[object String]' }\n\nvar isArray = Array.isArray || function isArray (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nforEach(objectKeys(Traverse.prototype), function (key) {\n    traverse[key] = function (obj) {\n        var args = [].slice.call(arguments, 1);\n        var t = new Traverse(obj);\n        return t[key].apply(t, args);\n    };\n});\n\nvar hasOwnProperty = Object.hasOwnProperty || function (obj, key) {\n    return key in obj;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/traverse/index.js\n// module id = 1875\n// module chunks = 1"],"sourceRoot":""}